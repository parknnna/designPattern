## Java Design Pattern

## 플라이 웨이트 패턴(Flyweight Pattern)

```
플라이웨이트 패턴은 객체를 공유하여 객체를 재사용해서 시스템을 절약할 수 있는 디자인 패턴이다.
fly(가볍다) + weight (무게) = 중복되는 코드의 객체를 공유해서 메모리를 적게 할당해서 무게가 가벼움
```

### 파사드 패팬이란?
* 플라이웨이트 패턴은 객체의 할당을 적게 하기 위한 패턴이며, 한 번 할당한 자원을 재사용함으로써 메모리를 관리한다.
* 플라이웨이트 패턴은 중복을 제거하고 공유를 통해 자원을 효율적으로 사용한다.
* 플라이웨이트 패턴은 보다 효율적인 공유 객체를 관리하기 위해 별도 저장소를 갖고 있는데 이를 공유 저장소라고 한다.
* 플라이웨이트 패턴은 팩토리 클래스에 공유 저장소를 추가하여 객체의 중복 생성 동작을 제한한다.
* 플라이웨이트 패턴은 무분별하게 객체를 생성하지 않고 기존 객체를 참조함으로써 중복을 방지한다. 이렇게 기존의 객체를 사용한 후 삭제하지 않고 재사용 혹은 공유할 경우 메모리 자원을 절약하는 것과 동시에 객체의 생성하는 자원과 시간도 같이 절약할 수 있다.
* 공유 객체가 상태 값에 종속적인 상태면 플라이웨이트 패턴으로 공유할 수 없다. 객체 상태가 변경됨으로써 참조하는 다른 객체에 사이드 이펙트 효과가 발생하기 때문이다.
* 대량의 객체를 생성 및 관리할 경우 플라이웨이트 패턴은 매우 유용한 대안이 될 수 있다. 또한 관리하는 객체의 수가 많아서 처리하기 힘든 경우에도 효과적이다.

### 최소 지식 원칙 (디미터 / 데메테르 원칙)
* 최소 지식만 적용해 객체의 상호 작용을 설정하면 유지 보수가 용이해진다.
* 불필요한 객체의 생성 루틴과 재호출을 코드에 코드에 삽입해 코드의 가독성과 복잡성을 증가시키지 않도록 한다.
* 최소 지식의 원칙
  * 자기 자신만의 객체 사용
  * 메서드에 전달된 매개변수 사용
  * 메서드에서 생성된 객체 사용
  * 객체에 속하는 메서드 사용

```java
public class Car {
    // 클래스의 구성 요소
    // 구성 요소의 메서드는 호출해도 된다.
    private Engine engine;
 
    public Car(Engine engine) {
        this.engine = engine;
    }
 
    public void start(CarKey key) {
        // 새로운 객체 생성
        // 내부에서 생성된 객체의 메서드는 호출해도 된다.
        Doors doors = new Doors();
 
        // 매개 변수로 전달된 객체의 메서드는 호출해도 된다.
        boolean authorized = key.turns();
 
        if (authorized) {
            // 객체의 구성 요소의 메서드는 호출해도 된다.
            engine.start();
 
            // 객체 내에 있는 메서드는 호출해도 된다.
            this.updateDashboardDisplay();
 
            // 직접 생성하거나 인스턴스를 만든 객체의 메서드는 호출해도 된다.
            doors.locks();
        }
    }
 
    private void updateDashboardDisplay() {
    }
}
```

### 파사드 패턴 구조
![FacadePattern](https://github.com/parknnna/designPattern/assets/69619672/c5988c8d-1a61-4997-9f84-53bed6225eb7)


### 파사드 패턴의 효과
* 서브 시스템 보호
  * 서브 시스템의 구성 요소를 직접 호출하지 않으므로 잘못된 사용을 방지
  * 내부 구조와 외부 사용을 구분하므로 추후 서브시스템 업그레이드에 자유로움
* 확장성
  * 코드 변경 시 상위 시스템에는 파사드를 이용하므로 서브 시스템이 변경되어도 큰 변화를 느낄 수 없음.
  * 확장성을 고려하면서 서브 시스템 기능을 유지할 수 있도록 완충하는 역할
* 결합도 감소
  * 서브 시스템이 복잡하고 종속성이 강할 때는 파사드 패턴 이용
  * 복잡한 종속적 결함도를 낮추고 독립적인 코드 유지 가능
* 계층화
  * 서브 시스템이 계층화된 구조를 갖더라도 파사드는 계층 단계별로 접근하여 행위를 호출할 수 있음.
* 이식성
  * 여러 작업을 하나의 묶음으로 처리하여 복잡한 클래스 단순화
  * 서브 시스템을 공통적으로 사용할 수 있도록 이식성을 향상
* 공개 인터페이스
  * 외부에 공개되는 기능과 공개되지 않는 기능을 구분 가능
  * 인터페이스를 제공함과 동시에 서브 시스템의 기능을 캡슐 화하여 일시적으로 특정 기능을 감추는 효과를 얻을 수 있음